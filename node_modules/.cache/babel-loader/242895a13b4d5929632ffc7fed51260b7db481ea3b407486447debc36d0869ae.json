{"ast":null,"code":"import _objectSpread from \"/home/sumran/lalal/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from 'hey-listen';\nimport { color } from '../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../value/types/complex/index.mjs';\nfunction getMixer(origin, target) {\n  if (typeof origin === \"number\") {\n    return v => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\nconst mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n  return v => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n    return output;\n  };\n};\nconst mixObject = (origin, target) => {\n  const output = _objectSpread(_objectSpread({}, origin), target);\n  const blendValue = {};\n  for (const key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n};\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.values, targetStats.values), template);\n  } else {\n    warning(true, \"Complex values '\".concat(origin, \"' and '\").concat(target, \"' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.\"));\n    return p => \"\".concat(p > 0 ? target : origin);\n  }\n};\nexport { mixArray, mixComplex, mixObject };","map":{"version":3,"names":["mix","mixColor","pipe","warning","color","complex","analyseComplexValue","getMixer","origin","target","v","test","mixComplex","mixArray","from","to","output","numValues","length","blendValue","map","fromThis","i","mixObject","_objectSpread","key","undefined","template","createTransformer","originStats","targetStats","canInterpolate","numColors","numNumbers","values","concat","p"],"sources":["/home/sumran/lalal/node_modules/framer-motion/dist/es/utils/mix-complex.mjs"],"sourcesContent":["import { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from 'hey-listen';\nimport { color } from '../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../value/types/complex/index.mjs';\n\nfunction getMixer(origin, target) {\n    if (typeof origin === \"number\") {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = { ...origin, ...target };\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.numColors === targetStats.numColors &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.values, targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p) => `${p > 0 ? target : origin}`;\n    }\n};\n\nexport { mixArray, mixComplex, mixObject };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}